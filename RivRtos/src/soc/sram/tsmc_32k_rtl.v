//---------------------------------------------------------------------
//               Copyright(c) Synopsys, Inc.                           
//     All Rights reserved - Unpublished -rights reserved under        
//     the Copyright laws of the United States of America.             
//                                                                     
//  U.S. Patents: 7,093,156 B1 and 7,406,620 B2 (and more pending).    
//                                                                     
//  This file includes the Confidential information of Synopsys, Inc.  
//  and TSMC.                                                          
//  The receiver of this Confidential Information shall not disclose   
//  it to any third party and shall protect its confidentiality by     
//  using the same degree of care, but not less than a reasonable      
//  degree of care, as the receiver uses to protect receiver's own     
//  Confidential Information.                                          
//  Licensee acknowledges and agrees that all output generated for     
//  Licensee by Synopsys, Inc. as described in the pertinent Program   
//  Schedule(s), or generated by Licensee through use of any Compiler  
//  licensed hereunder contains information that complies with the     
//  Virtual Component Identification Physical Tagging Standard (VCID)  
//  as maintained by the Virtual Socket Interface Alliance (VSIA).     
//  Such information may be expressed in GDSII Layer 63 or other such  
//  layer designated by the VSIA, hardware definition languages, or    
//  other formats.  Licensee is not authorized to alter or change any  
//  such information.                                                  
//---------------------------------------------------------------------
//                                                                     
//  Built for linux64 and running on linux64.                          
//                                                                     
//  Software           : Rev: W-2025.03                                
//  Library Format     : Rev: 1.05.00                                  
//  Compiler Name      : ts18ugfs1p11asssr512sb03                      
//  Platform           : Linux3.10.0-1160.119.1.el7.x86_64             
//                     : #1 SMP Tue Jun 4 14:43:51 UTC 2024x86_64      
//  Date of Generation : Mon Apr 07 14:26:30 PKT 2025                  
//                                                                     
//---------------------------------------------------------------------
/***********************************************************
***********************************************************
***********************************************************
   WARNING: THIS MODEL WILL BE PHASED OUT IN SUBSEQUENT RELEASE OF
   THIS COMPILER. INSTEAD, PLS. START USING THE VERILOG BEHAVIORAL MODEL
   WITH A COMMAND LINE ARGUMENT OF +define+VIRAGE_FAST_VERILOG.
   PLS. REFER TO RELEASE NOTES FOR MORE DETAILS 
***********************************************************
***********************************************************
*************************************************************/
//   --------------------------------------------------------------     
//                       Template Revision : 3.2.2                      
//   --------------------------------------------------------------     
//                      * Synchronous, 1-Port SRAM *                  
//                      * Verilog Behavioral Model *                  
//                THIS IS A SYNCHRONOUS 1-PORT MEMORY MODEL           
//                                                                    
//   Memory Name:tsmc_32k                                             
//   Memory Size:8192 words x 32 bits                                 
//                                                                    
//                               PORT NAME                            
//                               ---------                            
//               Output Ports                                         
//                                   Q[31:0]                          
//               Input Ports:                                         
//                                   ADR[12:0]                        
//                                   D[31:0]                          
//                                   WEM[31:0]                        
//                                   WE                               
//                                   OE                               
//                                   ME                               
//                                   CLK                              
//                                   RM[3:0]                          

`resetall 
`timescale 1 ns / 1 ps 
`celldefine 
`ifdef verifault // for fault simulation purpose 
`suppress_faults 
`enable_portfaults 
`endif 

`define True    1'b1
`define False   1'b0

module tsmc_32k ( Q, ADR, D, WEM, WE, OE, ME, CLK, RM);

output  [31:0] Q;
input  [12:0] ADR;
input  [31:0] D;
input  [31:0] WEM;
input WE;
input OE;
input ME;
input CLK;
input  [3:0] RM;


// Local registers, wires, etc
reg flag_ignore_read_addx;
wire [31:0] WEM_buf;
assign WEM_buf =   {  WEM } ;
wire WE_buf;
assign WE_buf =   WE ;
wire OE_buf;
assign OE_buf =   OE ;
wire ME_buf;
assign ME_buf =   ME ;

initial
  begin
    `ifdef  virage_ignore_read_addx
       flag_ignore_read_addx = 0;
    `else
       flag_ignore_read_addx = 1;
    `endif
  end

generic_tsmc_32k u0 ( Q,ADR,D,WEM_buf,WE_buf,OE_buf,ME_buf,CLK,RM, flag_ignore_read_addx );

endmodule
`endcelldefine 
`ifdef verifault 
`disable_portfaults 
`nosuppress_faults 
`endif 



module generic_tsmc_32k ( Q, ADR, D, WEM, WE, OE, ME, CLK, RM, flag_ignore_read_addx);
parameter  words = 8192, bits = 32, addrbits = 13, timingmode = 1,rmbits = 4,wembits = 32;

output [bits-1:0] Q;
input [addrbits-1:0] ADR;
input [bits-1:0] D;
input [wembits-1:0] WEM;
input WE;
input OE;
input ME;
input CLK;
input [rmbits-1:0] RM;

input flag_ignore_read_addx;

parameter DataX = { bits { 1'bx } };
parameter DataZ = { bits { 1'bz } };
`ifdef MEM_CHECK_OFF
parameter MES_ALL = "OFF";
`else
parameter MES_ALL = "ON";
`endif

reg [bits-1:0] QI;
reg CLK_old;
reg [addrbits-1:0] ADR_tmp;

reg [bits-1:0] D_tmp;

reg [wembits-1:0] WEM_tmp;

reg WE_tmp;
reg ME_tmp;
reg [rmbits-1:0] RM_tmp;

reg WE_old;
reg WE_lat;
reg [addrbits-1:0] ADR_old;

reg [addrbits-1:0] ADR_lat;

reg [bits-1:0] D_old;

reg [bits-1:0] D_lat;

reg [wembits-1:0] WEM_old;

reg [wembits-1:0] WEM_lat;

reg ME_old;
reg ME_lat;
reg [bits-1:0] Q;
reg [bits-1:0] QI_subword;
reg [bits-1:0] WEM_all;
wire [bits-1:0] WEM_all_old;
integer WEM_cnt;
integer i,j;
real OUT_risetime;
reg [bits-1:0] mem_core_array [0:words -1];

reg mes_flag;

initial
  mes_flag = 0;


assign WEM_all_old = {  WEM_old };

//====< Aport >====
//-- Aport Data Output
always @ (OE or QI) begin
                if(OE) begin
                    Q <= QI;
                end
                else if( !OE ) begin
                   Q <=  DataZ;
                end
                else if( OE===1'bx ) begin
                         if( MES_ALL=="ON" && CLK===1'b1 && OUT_risetime !=$realtime && $realtime != 0 && mes_flag == 1'b1 ) begin
                                 $display("<<OE unknown>>");
                                 $display("      time=%t; instance=%m (RAMS1H)",$realtime);
                         end
                       Q <=   DataX;
                end
        OUT_risetime <= $realtime;
end


always @( negedge CLK or WE )
   begin
       if ( CLK == 1'b0 )
       WE_old = WE;
   end
always @( negedge CLK or ADR )
   begin
       if ( CLK == 1'b0 )
       ADR_old = ADR;
   end
always @( negedge CLK or D )
   begin
       if ( CLK == 1'b0 )
       D_old = D;
   end
always @( negedge CLK or WEM )
   begin
       if ( CLK == 1'b0 )
       WEM_old = WEM;
   end
always @( negedge CLK or ME )
   begin
       if ( CLK == 1'b0 )
       ME_old = ME;
   end
//-- Internal Data Set
always @( posedge CLK ) begin
       WE_lat = WE_old;
       ADR_lat = ADR_old;
       D_lat = D_old;
       WEM_lat = WEM_old;
       WEM_all = WEM_all_old;
       ME_lat = ME_old;
        CLK_old <= CLK;
        if( CLK===1'bx ) begin //CLK="0->X"
             if( MES_ALL=="ON" && mes_flag == 1'b1 ) begin
                 $display("<<CLK unknown>>");
                 $display("      time=%t; instance=%m (RAMS1H)",$realtime);
             end
             for ( i=0; i<words ; i=i+1 ) begin
                 mem_core_array[i] <= DataX;
             end
             QI <=  DataX;
        end
        else if( CLK_old===1'bx && CLK===1'b1 ) begin
             QI <=  DataX;
        end
//---- Normal Mode
        else begin
                if( ME_lat===1'bx ) begin
                        if( MES_ALL=="ON" && mes_flag == 1'b1 ) begin
                                $display("<<ME unknown>>");
                                $display("      time=%t; instance=%m (RAMS1H)",$realtime);
                            
                        end
//                        if( WE_lat!==0 ) begin
                                if( ^ADR_lat===1'bx ) begin                      //Memory Break(All)
                                        if( MES_ALL=="ON" && mes_flag == 1'b1 ) begin
                                                 $display("<<ADR unknown , memory broken>>") ;
                                                 $display("      time=%t; instance=%m (RAMS1H)",$realtime);
                                             
                                        end
                                        for ( i=0; i<words ; i=i+1 ) begin
                                                mem_core_array[i] <= DataX;
                                        end
                                end
                                else if( !( ADR_lat >= words ) ) begin
                                  if ( !(WE_lat == 1'b0 && flag_ignore_read_addx == 0) )
     			          begin //flag_ignore_read_addx
                                        if( MES_ALL=="ON" && mes_flag == 1'b1 ) begin
                                                $display("<<ADR Fix, But memory broken>>") ;
                                                $display("      time=%t; instance=%m (RAMS1H)",$realtime);
                                        end
                                        for ( i=0; i<words ; i=i+1 ) begin
                                                mem_core_array[i] <= DataX;
                                        end
     			          end //flag_ignore_read_addx
                                end
//                        end
                        QI <=  DataX;
                end
//---- CLEAR none, ME_lat=1
                else if( ME_lat ) begin
                        if( !WE_lat ) begin


                                if (RM != 4'b1000)
                                begin
                                  if( MES_ALL=="ON" && mes_flag == 1'b1 )
                                  begin
                                    $display("RM = %b is not recommended value\n",RM);
                                    $display("      time=%t; instance=%m (RAMS1H)",$realtime);
                                  end
                                end

                                if( ^RM ===1'bx ) 
                                     QI <=  DataX;
                                else if(^ADR_lat===1'bx ) begin                          //Memory Break(All)
                                         if( MES_ALL=="ON" && mes_flag == 1'b1 ) begin
                                                $display("<<ADR unknown>>") ;
                                                $display("      time=%t; instance=%m (RAMS1H)",$realtime);
                                             
                                         end
                                     if (flag_ignore_read_addx)
     				       begin //flag_ignore_read_addx
                                           for ( i=0; i<words ; i=i+1 ) begin
                                                mem_core_array[i] <= DataX;
                                           end
			               end   //flag_ignore_read_addx
                                                QI <=  DataX;
                                end
                                else if( ADR_lat >= words ) begin
                                        if( MES_ALL=="ON" && mes_flag == 1'b1 ) begin
                                                $display("<<No memory cell at Address=%b ( %d )>>",ADR,ADR);
                                                $display("      time=%t; instance=%m (RAMS1H)",$realtime);
                                        end
                                                QI <=  DataX;
                                end
                                else begin
                                                QI <=  mem_core_array[ADR_lat];
                                                if (mes_flag == 0) mes_flag = 1;
                                end    //ADR_lat switch
                        end                                                     //WE_lat switch
//---- WriteMode
                        else if( WE_lat ) begin
                                if(^ADR_lat===1'bx ) begin
                                         if( MES_ALL=="ON" && mes_flag == 1'b1 ) begin
                                                $display("<<ADR unknown >>") ;
                                                $display("      time=%t; instance=%m (RAMS1H)",$realtime);
                                            
                                         end
                                        WEM_cnt = 0 ;
                                        for ( i=0; i < wembits ; i=i+1 ) begin    //Count WEM
                                                if( WEM_lat[i]==1'b1 ) begin
                                                        WEM_cnt = WEM_cnt + 1 ;
                                                end
                                        end
                                        if( WEM_cnt!=0 ) begin                  //Memory Break(WEM Bit)
                                                if( MES_ALL=="ON" && mes_flag == 1'b1 ) 
                                                   $display("<< memory broken>>") ;
                                                for ( i=0; i<words ; i=i+1 ) begin
                                                        mem_core_array[i] <= DataX;
                                                end
                                        end
                                                QI_subword = QI;
                                                QI <=  (( QI_subword & ~WEM_all ) | ( D_lat & WEM_all)) ^ (WEM_all ^ WEM_all);
                                end
                                else if( ADR_lat >= words ) begin
                                        if( MES_ALL=="ON" && mes_flag == 1'b1 ) begin
                                                $display("<<No memory cell at Address=%b ( %d )>>",ADR,ADR);
                                                $display("      time=%t; instance=%m (RAMS1H)",$realtime);
                                        end
                                                QI_subword = QI;
                                                QI <=  (( QI_subword & ~WEM_all ) | ( D_lat & WEM_all)) ^ (WEM_all ^ WEM_all);
                                end
                                else begin
                                if(^D_lat===1'bx ) begin
                                         if( MES_ALL=="ON" && mes_flag == 1'b1 ) begin
                                                $display("<<D unknown >>") ;
                                                $display("      time=%t; instance=%m (RAMS1H)",$realtime);
                                            
                                         end
                                end
                                        WEM_cnt = 0 ;
                                        for ( i=0; i < wembits ; i=i+1 ) begin    //Count WEM("X")
                                                if( WEM_lat[i]===1'bx ) begin
                                                        WEM_cnt = WEM_cnt + 1 ;
                                                end
                                        end
                                        if( !WEM_cnt ) begin                    //NormalWrite
                                                mem_core_array[ADR_lat] <= ( mem_core_array[ADR_lat] & ~WEM_all ) | ( D_lat & WEM_all );
                                                        QI_subword = QI;
                                                        QI <=  ( QI_subword & ~WEM_all ) | ( D_lat & WEM_all );
                                        end
                                        else if( WEM_cnt!=0 ) begin             //Memory Break
                                                if( MES_ALL=="ON" && mes_flag == 1'b1 ) begin
                                                        $display("<<WEM unknown>>");
                                                        $display("      time=%t; instance=%m (RAMS1H)",$realtime);
                                            
                                                end
                                                mem_core_array[ADR_lat] <= DataX;
                                                        QI <=  DataX;
                                        end
                                                        if (mes_flag == 0) mes_flag = 1;

                                end                                             //ADR_lat switch
                        end                                                     //WE_lat switch
                        else if( WE_lat===1'bx ) begin
                                if( MES_ALL=="ON" && mes_flag == 1'b1 ) begin
                                       $display("<<WE unknown>>");
                                       $display("      time=%t; instance=%m (RAMS1H)",$realtime);
                                            
                                end
                                if( ^ADR_lat===1'bx ) begin                         //Memory Break(All)
                                        if( MES_ALL=="ON" && mes_flag == 1'b1 ) begin
                                                $display("<<ADR unknown >>") ;
                                                $display("      time=%t; instance=%m (RAMS1H)",$realtime);
                                            
                                        end
                                        WEM_cnt = 0 ;
                                        for ( i=0; i < wembits ; i=i+1 ) begin    //Count WEM
                                                if( WEM_lat[i]==1'b1 ) begin
                                                        WEM_cnt = WEM_cnt + 1 ;
                                                end
                                        end
                                        if( WEM_cnt!=0 ) begin                  //Memory Break(WEM Bit)
                                                if( MES_ALL=="ON" && mes_flag == 1'b1 ) 
                                                   $display("<< memory broken>>") ;
                                                for ( i=0; i<words ; i=i+1 ) begin
                                                        mem_core_array[i] <= DataX;
                                                end
                                        end
                                                QI <=  DataX;
                                end
                                else if( ADR_lat >= words ) begin
                                        if( MES_ALL=="ON" && mes_flag == 1'b1 ) begin
                                                $display("<<No memory cell at Address=%b ( %d )>>",ADR,ADR);
                                                $display("      time=%t; instance=%m (RAMS1H)",$realtime);
                                        end
                                                QI <=  DataX;
                                end
                                else begin
                                        mem_core_array[ADR_lat] <= DataX;
                                                QI <=  DataX;
                                end //ADR_lat switch
                        end  //WE_lat switch
                end

        end
end
//---- Clock Negative Edge 
always @( negedge CLK) begin
   CLK_old <= CLK;
   if ( CLK_old ===1'b1 && CLK===1'bx) begin
      if( MES_ALL=="ON" && mes_flag == 1'b1 ) begin 
        $display("<<CLK unknown>>");
        $display("      time=%t; instance=%m (RAMS1H)",$realtime);
      end 
      for ( i=0; i<words ; i=i+1 ) begin     //Memory Broken
          mem_core_array[i] <= DataX;
      end
      QI <=  DataX;
   end
end


endmodule
